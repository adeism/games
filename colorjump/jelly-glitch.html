<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jelly Glitch Party 2.0</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #2c2836; 
            font-family: 'Nunito', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #gameContainer {
            position: relative;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            border-radius: 20px;
            overflow: hidden;
            border: 4px solid #4a455a;
            
            /* TAMPILAN LEBIH BESAR */
            width: 90vw;       /* Menggunakan 90% lebar layar */
            max-width: 1600px; /* Batas maksimal agar tidak terlalu pecah di layar ultrawide */
            aspect-ratio: 16/9; /* Menjaga rasio layar */
            background: #000; /* Letterbox hitam jika rasio layar aneh */
        }

        canvas {
            display: block;
            background-color: #2c2836;
            width: 100%;
            height: 100%;
            /* image-rendering: pixelated;  Opsional: aktifkan jika ingin gaya retro kotak-kotak */
        }

        /* UI Overlay Layer */
        #uiLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 30px; /* Padding sedikit lebih besar */
            box-sizing: border-box;
        }

        /* Top HUD */
        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .timer-box {
            background: #fff;
            padding: 15px 35px; /* Lebih besar */
            border-radius: 50px;
            color: #333;
            font-family: 'Fredoka One', cursive;
            font-size: 36px; /* Font lebih besar */
            box-shadow: 0 6px 0 #ccc;
            transform: rotate(-2deg);
            transition: transform 0.2s;
        }

        .speed-meter {
            background: rgba(0,0,0,0.3);
            padding: 8px 20px;
            border-radius: 30px;
            color: #fff;
            font-weight: bold;
            font-size: 20px; /* Font lebih besar */
        }

        /* Controls Visualizer */
        .controls-hud {
            display: flex;
            gap: 20px;
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 60px;
            backdrop-filter: blur(5px);
            margin-bottom: 20px;
            transform: scale(1.2); /* UI Kontrol diperbesar */
        }

        .key-cap {
            width: 50px; /* Lebih besar */
            height: 50px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Fredoka One', cursive;
            font-size: 24px;
            color: #fff;
            opacity: 0.5;
            transition: all 0.1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: 4px solid rgba(255,255,255,0.5);
            text-shadow: 1px 1px 0 rgba(0,0,0,0.3);
        }

        .key-cap.active {
            opacity: 1;
            transform: scale(1.3) translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            border-color: #fff;
        }

        /* Start/End Screens */
        #menuOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(44, 40, 54, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            backdrop-filter: blur(8px);
            z-index: 10;
            transition: opacity 0.5s;
        }

        h1 {
            color: #fff;
            font-family: 'Fredoka One', cursive;
            font-size: 80px; /* Judul Raksasa */
            margin: 0 0 15px 0;
            text-shadow: 6px 6px 0 #ff6b6b;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-10px) rotate(2deg); }
        }

        .btn {
            background: #ffcc00;
            color: #333;
            border: none;
            padding: 20px 60px; /* Tombol lebih besar */
            font-family: 'Fredoka One', cursive;
            font-size: 32px;
            border-radius: 60px;
            cursor: pointer;
            transition: 0.2s;
            box-shadow: 0 8px 0 #d4a000;
            margin-bottom: 25px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 0 #d4a000;
            background: #ffe066;
        }

        .btn:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #d4a000;
        }

        .tutorial-text {
            color: #ddd;
            margin-top: 15px;
            font-size: 22px; /* Teks tutorial lebih jelas */
            text-align: center;
            line-height: 1.6;
            background: rgba(0,0,0,0.2);
            padding: 30px;
            border-radius: 20px;
        }

        .hidden { display: none !important; opacity: 0; pointer-events: none; }

        /* Easter Egg Notification */
        #notification {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Fredoka One', cursive;
            font-size: 60px; /* Notifikasi lebih besar */
            color: #fff;
            text-shadow: 0 0 20px #ff00ff;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            z-index: 20;
        }
        #notification.show { opacity: 1; animation: pulse 0.5s infinite; }
        
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

    </style>
</head>
<body>

    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <div id="uiLayer">
            <div class="hud-top">
                <div class="timer-box" id="timerDisplay">00.00</div>
                <div class="speed-meter" id="velocityDisplay">0 km/h</div>
            </div>
            
            <div id="notification">DISCO MODE!</div>

            <div style="display: flex; justify-content: center; width: 100%;">
                <div class="controls-hud">
                    <div class="key-cap" id="key1" style="background: #ff6b6b;">1</div>
                    <div class="key-cap" id="key2" style="background: #51cf66;">2</div>
                    <div class="key-cap" id="key3" style="background: #4dabf7;">3</div>
                    <div class="key-cap" id="key4" style="background: #ffd43b;">4</div>
                </div>
            </div>
        </div>

        <div id="menuOverlay">
            <h1>Jelly Glitch</h1>
            <button class="btn" onclick="startGame()">MULAI!</button>
            <div class="tutorial-text">
                <b>WASD / Panah</b> untuk Loncat-loncat<br>
                <b>1-2-3-4</b> ganti Rasa (Warna)<br>
                <span style="color: #51cf66; font-weight: bold;">TRIK RAHASIA:</span> Masuk ke dalam jeli warna lain,<br>lalu ganti warna di dalam buat <b>TERPELANTING!</b>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Setup Canvas Size (Internal Resolution - Keep Fixed for Physics consistency)
        const GAME_WIDTH = 960;
        const GAME_HEIGHT = 540;
        canvas.width = GAME_WIDTH;
        canvas.height = GAME_HEIGHT;

        // Constants & Physics Tuning
        const GRAVITY = 0.55;
        const TERMINAL_VELOCITY = 16;
        const ACCEL = 1.2;
        const FRICTION = 0.85; 
        const JUMP_FORCE = -11.5; 
        const GLITCH_FORCE = 26; 
        const TIME_SCALE_SLOW = 0.2; 

        // Colors (Candy Palette)
        const PALETTE = {
            1: { hex: '#ff6b6b', shadow: '#c92a2a', name: 'Strawberry' },   // Red
            2: { hex: '#51cf66', shadow: '#2b8a3e', name: 'Lime' },         // Green
            3: { hex: '#4dabf7', shadow: '#1864ab', name: 'Blueberry' },    // Blue
            4: { hex: '#ffd43b', shadow: '#f08c00', name: 'Lemon' }         // Yellow
        };

        // Game Engine State
        let state = {
            running: false,
            timeScale: 1.0,
            startTime: 0,
            elapsed: 0,
            camera: { x: 0, y: 0, shake: 0 },
            particles: [],
            shouts: [], 
            platforms: [],
            bubbles: [], // Background bubbles
            player: null,
            keys: {},
            lastJumpPress: 0, 
            victory: false,
            discoMode: false,
            discoTimer: 0
        };

        // --- CLASSES ---

        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.w = 28; 
                this.h = 28;
                this.vx = 0;
                this.vy = 0;
                this.color = 1;
                this.grounded = false;
                this.coyoteTime = 0;
                this.facingRight = true;
                
                // Spring Physics for animation
                this.squash = { x: 1, y: 1 };
                this.squashVel = { x: 0, y: 0 };
                
                // Easter Egg States
                this.idleTimer = 0;
                this.isSleeping = false;
            }

            update() {
                // Input Processing
                let moveInput = false;
                if (state.keys['ArrowRight'] || state.keys['KeyD']) {
                    this.vx += ACCEL;
                    this.facingRight = true;
                    moveInput = true;
                }
                if (state.keys['ArrowLeft'] || state.keys['KeyA']) {
                    this.vx -= ACCEL;
                    this.facingRight = false;
                    moveInput = true;
                }
                
                // Idle Check
                if (!moveInput && Math.abs(this.vx) < 0.5 && Math.abs(this.vy) < 0.5) {
                    this.idleTimer++;
                    if (this.idleTimer > 300) this.isSleeping = true; // 5 seconds
                } else {
                    this.idleTimer = 0;
                    this.isSleeping = false;
                }

                if (this.isSleeping && Math.random() < 0.02) {
                    createShout(this.x + 10, this.y - 10, "Zzz...", true);
                }

                // Physics
                this.vx *= FRICTION;
                if (Math.abs(this.vx) < 0.1) this.vx = 0;

                this.vy += GRAVITY * state.timeScale;
                if (this.vy > TERMINAL_VELOCITY) this.vy = TERMINAL_VELOCITY;

                this.x += this.vx * state.timeScale;
                this.checkCollisions(true);

                this.y += this.vy * state.timeScale;
                this.grounded = false;
                this.checkCollisions(false);

                // Spring Physics Logic (Hooke's Law for Squash/Stretch)
                // Target is always 1,1
                const k = 0.15; // Stiffness
                const d = 0.8;  // Damping
                
                const forceX = (1 - this.squash.x) * k;
                const forceY = (1 - this.squash.y) * k;
                
                this.squashVel.x += forceX;
                this.squashVel.y += forceY;
                
                this.squashVel.x *= d;
                this.squashVel.y *= d;
                
                this.squash.x += this.squashVel.x;
                this.squash.y += this.squashVel.y;

                // Coyote & Jump
                if (this.grounded) this.coyoteTime = 6; 
                else this.coyoteTime--;

                if (state.keys['Space'] || state.keys['ArrowUp'] || state.keys['KeyW']) {
                    state.lastJumpPress = 6;
                    state.keys['Space'] = false;
                }
                if (state.lastJumpPress > 0) state.lastJumpPress--;

                if (state.lastJumpPress > 0 && (this.grounded || this.coyoteTime > 0)) {
                    this.vy = JUMP_FORCE;
                    this.grounded = false;
                    this.coyoteTime = 0;
                    state.lastJumpPress = 0;
                    
                    // Trigger Squash on Jump
                    this.applySquash(0.6, 1.4);
                    
                    createParticles(this.x + this.w/2, this.y + this.h, PALETTE[this.color].hex, 5, 'dust');
                }

                // Glitch Check
                this.checkGlitchZone();

                // Fall Death
                if (this.y > 2000) resetLevel();
            }

            applySquash(x, y) {
                this.squash.x = x;
                this.squash.y = y;
                this.squashVel.x = 0;
                this.squashVel.y = 0;
            }

            checkCollisions(horizontal) {
                for (let p of state.platforms) {
                    if (p.color !== this.color) continue;

                    if (this.x < p.x + p.w && this.x + this.w > p.x &&
                        this.y < p.y + p.h && this.y + this.h > p.y) {
                        
                        if (horizontal) {
                            if (this.vx > 0) this.x = p.x - this.w;
                            else if (this.vx < 0) this.x = p.x + p.w;
                            this.vx = 0;
                            this.applySquash(0.7, 1.3); // Hit wall
                        } else {
                            if (this.vy > 0) { // Landing
                                this.y = p.y - this.h;
                                if (!this.grounded) {
                                    // Impact force determines squash
                                    let impact = Math.min(Math.abs(this.vy) * 0.05, 0.4);
                                    this.applySquash(1 + impact, 1 - impact); 
                                }
                                this.grounded = true;
                                this.vy = 0;
                            } else if (this.vy < 0) { // Ceiling
                                this.y = p.y + p.h;
                                this.vy = 0;
                                this.applySquash(1.3, 0.7); // Bonk head
                            }
                        }
                    }
                }
            }

            checkGlitchZone() {
                let insideBlock = false;
                for (let p of state.platforms) {
                    if (p.color === this.color) continue; 

                    if (this.x + 8 < p.x + p.w && this.x + this.w - 8 > p.x &&
                        this.y + 8 < p.y + p.h && this.y + this.h - 8 > p.y) {
                        insideBlock = true;
                        p.highlight = true;
                    } else {
                        p.highlight = false;
                    }
                }
                const targetScale = insideBlock ? TIME_SCALE_SLOW : 1.0;
                state.timeScale += (targetScale - state.timeScale) * 0.2;
            }

            switchColor(newColor) {
                if (this.color === newColor) return;
                
                createParticles(this.x + this.w/2, this.y + this.h/2, PALETTE[this.color].hex, 8, 'confetti');
                this.color = newColor;
                updateUIKeys(newColor);

                for (let p of state.platforms) {
                    if (p.color === newColor) {
                        if (this.x < p.x + p.w && this.x + this.w > p.x &&
                            this.y < p.y + p.h && this.y + this.h > p.y) {
                            
                            let dx = (this.x + this.w/2) - (p.x + p.w/2);
                            let dy = (this.y + this.h/2) - (p.y + p.h/2);
                            
                            let dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist === 0) { dx = 0; dy = -1; dist = 1; }
                            
                            this.vx = (dx / dist) * GLITCH_FORCE;
                            this.vy = (dy / dist) * GLITCH_FORCE;

                            state.camera.shake = 25;
                            state.timeScale = 0.05; 
                            setTimeout(() => { state.timeScale = 1.0 }, 150);
                            createParticles(this.x + this.w/2, this.y + this.h/2, '#FFF', 40, 'explosion');
                            
                            // Extreme Squash on Launch
                            this.applySquash(0.4, 1.6);

                            const words = ["BOING!", "YEET!", "WUSH!", "LUNCUR!", "ADUH!"];
                            const word = words[Math.floor(Math.random() * words.length)];
                            createShout(this.x, this.y - 40, word);
                        }
                    }
                }
            }

            draw(ctx) {
                const c = PALETTE[this.color];
                
                ctx.save();
                ctx.translate(this.x + this.w/2, this.y + this.h/2);
                
                // Combine physics squash with speed stretch
                let speedStretchX = 1 + (Math.abs(this.vx) * 0.02);
                let speedStretchY = 1 + (Math.abs(this.vy) * 0.02);
                
                // Rotate towards velocity if moving fast
                if (Math.abs(this.vx) > 1 || Math.abs(this.vy) > 1) {
                    let angle = Math.atan2(this.vy, this.vx * 2); // Dampen x for visual effect
                    if (!this.grounded) {
                        ctx.rotate(angle * 0.5); // Tilt slightly towards movement
                    }
                }

                ctx.scale(this.squash.x * speedStretchX, this.squash.y / speedStretchX); // Preserve volume roughly

                // Body
                ctx.fillStyle = c.hex;
                ctx.beginPath();
                ctx.roundRect(-this.w/2, -this.h/2 + 4, this.w, this.h, 10);
                ctx.fillStyle = c.shadow;
                ctx.fill();

                ctx.beginPath();
                ctx.roundRect(-this.w/2, -this.h/2, this.w, this.h, 10);
                ctx.fillStyle = c.hex;
                ctx.fill();
                
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.beginPath();
                ctx.ellipse(-6, -8, 4, 3, Math.PI/4, 0, Math.PI*2);
                ctx.fill();

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.stroke();

                // FACE LOGIC
                ctx.fillStyle = '#333';
                
                // Look direction
                let lookX = this.facingRight ? 4 : -4;
                if (Math.abs(this.vx) > 1) lookX = (this.vx / 10) * 6;
                
                // Speed Check for Sunglasses
                let speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
                let isFast = speed > 12;

                if (isFast) {
                    // Cool Sunglasses
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.roundRect(-10 + lookX, -4, 20, 6, 2);
                    ctx.fill();
                    ctx.fillStyle = 'rgba(255,255,255,0.5)'; // Glare
                    ctx.fillRect(-8 + lookX, -3, 6, 2);
                } else if (this.isSleeping) {
                    // Sleeping Eyes
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = '#333';
                    ctx.beginPath();
                    ctx.moveTo(-8, 0); ctx.lineTo(-2, 0);
                    ctx.moveTo(2, 0); ctx.lineTo(8, 0);
                    ctx.stroke();
                } else {
                    // Normal Eyes
                    ctx.beginPath();
                    ctx.arc(-5 + lookX, -2, 3, 0, Math.PI*2); 
                    ctx.arc(5 + lookX, -2, 3, 0, Math.PI*2);  
                    ctx.fill();
                }

                // Mouth
                ctx.beginPath();
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#333';
                if (speed > 15) {
                    // Screaming mouth
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(0 + lookX, 5, 3, 0, Math.PI*2);
                    ctx.fill();
                } else if (this.isSleeping) {
                    // Snoring mouth
                    ctx.beginPath();
                    ctx.arc(0, 5, 2, 0, Math.PI*2);
                    ctx.stroke();
                } else {
                    // Smile
                    ctx.arc(0 + lookX, 4, 3, 0, Math.PI, false);
                    ctx.stroke();
                }

                ctx.restore();
            }
        }

        // --- VISUALS ---

        class Shout {
            constructor(x, y, text, small = false) {
                this.x = x; this.y = y; this.text = text;
                this.life = 1.0;
                this.vy = -2;
                this.small = small;
            }
            update() {
                this.y += this.vy;
                this.life -= 0.02;
            }
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.translate(this.x, this.y);
                
                ctx.fillStyle = '#fff';
                ctx.strokeStyle = '#333';
                ctx.lineWidth = this.small ? 2 : 3;
                ctx.font = this.small ? "bold 16px 'Fredoka One'" : "bold 24px 'Fredoka One'";
                ctx.textAlign = "center";
                
                ctx.strokeText(this.text, 0, 0);
                ctx.fillText(this.text, 0, 0);
                
                ctx.restore();
            }
        }

        function createShout(x, y, text, small=false) {
            state.shouts.push(new Shout(x, y, text, small));
        }

        class Particle {
            constructor(x, y, color, type) {
                this.x = x; this.y = y; this.color = color; this.type = type;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * (type === 'explosion' ? 10 : 4);
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.decay = Math.random() * 0.03 + 0.02;
                this.size = Math.random() * 6 + 3;
                this.rotation = Math.random() * Math.PI;
            }
            update() {
                this.x += this.vx * state.timeScale;
                this.y += this.vy * state.timeScale;
                this.vy += 0.2 * state.timeScale; 
                this.life -= this.decay;
                this.size *= 0.95;
                this.rotation += 0.2;
            }
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                if (this.type === 'confetti') {
                    ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                } else {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size/2, 0, Math.PI*2);
                    ctx.fill();
                }
                ctx.restore();
            }
        }

        class Bubble {
            constructor() {
                this.init();
            }
            init() {
                this.x = Math.random() * GAME_WIDTH;
                this.y = Math.random() * GAME_HEIGHT + GAME_HEIGHT; // Start below
                this.size = Math.random() * 20 + 5;
                this.speed = Math.random() * 1 + 0.5;
                this.wobble = Math.random() * Math.PI * 2;
            }
            update() {
                this.y -= this.speed;
                this.wobble += 0.05;
                this.x += Math.sin(this.wobble) * 0.5;
                if (this.y < -50) this.init(); // Reset
            }
            draw(ctx) {
                ctx.fillStyle = 'rgba(255,255,255,0.05)';
                if (state.discoMode) {
                    ctx.fillStyle = `hsl(${Math.random()*360}, 70%, 50%)`;
                }
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
                ctx.fill();
            }
        }

        function createParticles(x, y, color, count, type) {
            for(let i=0; i<count; i++) state.particles.push(new Particle(x, y, color, type));
        }

        // --- LEVEL DESIGN ---

        function initLevel() {
            state.platforms = [];
            state.player = new Player(100, 300);
            
            const add = (x, y, w, h, c) => state.platforms.push({x, y, w, h, color: c, highlight: false});

            // 1. Safe Zone (Learning Controls) - LANTAI LEBIH PANJANG
            add(50, 400, 600, 40, 1); 

            // 2. Simple Steps (No Death Pits yet) - TANGGA MUDAH
            add(650, 350, 150, 30, 2); // Green
            add(800, 300, 150, 30, 3); // Blue
            add(950, 250, 150, 30, 4); // Yellow

            // 3. First Gap (Safe landing below) - LOMPATAN PERTAMA
            add(1100, 400, 500, 40, 1); // Red Safety Floor
            add(1200, 200, 100, 30, 2); // Platform in air
            
            // 4. Wall Climb Introduction (Easier)
            add(1400, 150, 40, 300, 3); // Blue Wall
            add(1550, 50, 40, 300, 4);  // Yellow Wall
            
            // 5. THE GLITCH TRAINING (Safe pit)
            add(1700, 450, 800, 40, 1); // Red Floor
            
            // The Block to Glitch Inside (Big & Obvious)
            // Player runs on Red, jumps into Green block, switches to Green to fly
            add(2100, 300, 150, 150, 2); 

            // Target (Big platform)
            add(2400, 100, 400, 30, 3);

            // 6. Victory Run
            add(2900, 150, 200, 30, 4);
            add(3200, 200, 200, 30, 1);
            
            // Goal
            add(3500, 200, 300, 40, 2); 

            // Init bubbles
            state.bubbles = [];
            for(let i=0; i<30; i++) {
                let b = new Bubble();
                b.y = Math.random() * GAME_HEIGHT; // Random start
                state.bubbles.push(b);
            }
        }

        // --- CORE LOOP ---

        function update() {
            if (!state.running) return;

            // Camera Smoothing
            let targetX = state.player.x - GAME_WIDTH * 0.3 + (state.player.vx * 15);
            let targetY = state.player.y - GAME_HEIGHT * 0.5 + (state.player.vy * 5);
            
            state.camera.x += (targetX - state.camera.x) * 0.08; // Softer ease
            state.camera.y += (targetY - state.camera.y) * 0.08;
            
            if (state.camera.shake > 0) {
                state.camera.x += (Math.random() - 0.5) * state.camera.shake;
                state.camera.y += (Math.random() - 0.5) * state.camera.shake;
                state.camera.shake *= 0.85;
                if (state.camera.shake < 0.5) state.camera.shake = 0;
            }

            state.player.update();

            // Background Bubbles
            state.bubbles.forEach(b => b.update());

            // Disco Mode Logic
            if (state.discoMode) {
                state.discoTimer++;
                if (state.discoTimer % 10 === 0) {
                    document.body.style.backgroundColor = `hsl(${state.discoTimer % 360}, 50%, 20%)`;
                }
            }

            // Particles
            for (let i = state.particles.length - 1; i >= 0; i--) {
                state.particles[i].update();
                if (state.particles[i].life <= 0) state.particles.splice(i, 1);
            }

            // Shouts
            for (let i = state.shouts.length - 1; i >= 0; i--) {
                state.shouts[i].update();
                if (state.shouts[i].life <= 0) state.shouts.splice(i, 1);
            }

            state.elapsed = (Date.now() - state.startTime) / 1000;
            document.getElementById('timerDisplay').innerText = state.elapsed.toFixed(2);
            document.getElementById('velocityDisplay').innerText = Math.round(Math.abs(state.player.vx) * 10);

            if (state.player.x > 3500 && state.player.grounded && !state.victory) {
                winGame();
            }
        }

        function draw() {
            // Background
            ctx.fillStyle = state.discoMode ? 'rgba(0,0,0,0.1)' : '#2c2836';
            if (state.discoMode) {
                // Trail effect in disco mode
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            } else {
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            }

            // Draw Bubbles (Parallax Background)
            ctx.save();
            state.bubbles.forEach(b => b.draw(ctx));
            ctx.restore();

            // Pattern Overlay
            ctx.save();
            ctx.fillStyle = 'rgba(255,255,255,0.03)';
            let gridOffset = -(state.camera.x * 0.2) % 100;
            for(let x=gridOffset; x<GAME_WIDTH; x+=100) { 
                for(let y=0; y<GAME_HEIGHT; y+=100) {
                    ctx.beginPath();
                    ctx.arc(x+50, y+50, 10, 0, Math.PI*2);
                    ctx.fill();
                }
            }
            ctx.restore();

            ctx.save();
            ctx.translate(-state.camera.x, -state.camera.y);

            // Tutorial Text
            ctx.font = "20px 'Fredoka One'";
            ctx.fillStyle = "#aaa";
            ctx.fillText("Jalan-jalan...", 100, 350);
            ctx.fillText("Ganti Rasa!", 700, 200); // Moved to match steps
            
            ctx.fillStyle = "#51cf66"; // Lime color
            ctx.font = "24px 'Fredoka One'";
            ctx.fillText("MASUK KE KOTAK LIME (HIJAU)", 2175, 250);
            ctx.fillText("GANTI KE LIME DI DALAM!", 2175, 280);

            // Platforms
            for (let p of state.platforms) {
                let isActive = state.player.color === p.color;
                let c = PALETTE[p.color];

                ctx.save();
                if (isActive) {
                    ctx.fillStyle = c.hex;
                    ctx.beginPath();
                    ctx.roundRect(p.x, p.y, p.w, p.h, 8);
                    ctx.fill();
                    
                    ctx.fillStyle = c.shadow;
                    ctx.beginPath();
                    ctx.roundRect(p.x, p.y + p.h - 8, p.w, 8, [0,0,8,8]);
                    ctx.fill();
                } else {
                    ctx.strokeStyle = c.hex;
                    ctx.lineWidth = 3;
                    ctx.globalAlpha = 0.3;
                    ctx.beginPath();
                    ctx.roundRect(p.x, p.y, p.w, p.h, 8);
                    ctx.stroke();
                    
                    if (p.highlight) {
                        ctx.globalAlpha = 1.0;
                        ctx.strokeStyle = '#fff';
                        ctx.setLineDash([8, 8]);
                        ctx.lineDashOffset = Date.now() / 20; 
                        ctx.strokeRect(p.x-4, p.y-4, p.w+8, p.h+8);
                        
                        ctx.fillStyle = '#fff';
                        ctx.font = "bold 16px 'Fredoka One'";
                        ctx.textAlign = "center";
                        ctx.fillText("PENCET " + p.color + "!", p.x + p.w/2, p.y - 15);
                    }
                }
                ctx.restore();
            }

            for (let p of state.particles) p.draw(ctx);
            state.player.draw(ctx);
            for (let s of state.shouts) s.draw(ctx);

            if (state.victory) {
                ctx.fillStyle = '#fff';
                ctx.font = "60px 'Fredoka One'";
                ctx.fillText("HOREEE!", 3500, -80);
            }

            ctx.restore();

            requestAnimationFrame(loop);
        }

        function loop() {
            update();
            draw();
        }

        // --- INPUT & STATE MANAGEMENT ---

        function startGame() {
            document.getElementById('menuOverlay').classList.add('hidden');
            resetLevel();
            state.running = true;
            loop();
        }

        function resetLevel() {
            initLevel();
            state.startTime = Date.now();
            state.victory = false;
            state.camera.x = 0; 
            state.camera.y = 0;
            state.particles = [];
            state.shouts = [];
            state.discoMode = false;
            document.body.style.backgroundColor = '#2c2836';
            updateUIKeys(1);
        }

        function winGame() {
            state.victory = true;
            state.running = false;
            document.getElementById('menuOverlay').classList.remove('hidden');
            document.querySelector('#menuOverlay h1').innerText = "WAKTU: " + state.elapsed.toFixed(2) + "s";
            document.querySelector('#menuOverlay button').innerText = "LAGI DONG!";
        }

        function updateUIKeys(activeId) {
            for(let i=1; i<=4; i++) {
                const el = document.getElementById('key'+i);
                if (i === activeId) el.classList.add('active');
                else el.classList.remove('active');
            }
        }

        // KONAMI CODE DETECTOR
        const konamiCode = ["ArrowUp","ArrowUp","ArrowDown","ArrowDown","ArrowLeft","ArrowRight","ArrowLeft","ArrowRight","KeyB","KeyA"];
        let konamiIndex = 0;

        window.addEventListener('keydown', e => {
            // Game Input
            state.keys[e.code] = true;
            if (['Digit1','Digit2','Digit3','Digit4'].includes(e.code)) {
                state.player.switchColor(parseInt(e.key));
            }

            // Easter Egg Input
            if (e.code === konamiCode[konamiIndex]) {
                konamiIndex++;
                if (konamiIndex === konamiCode.length) {
                    activateDiscoMode();
                    konamiIndex = 0;
                }
            } else {
                konamiIndex = 0;
            }
        });

        window.addEventListener('keyup', e => state.keys[e.code] = false);

        function activateDiscoMode() {
            state.discoMode = !state.discoMode;
            const notif = document.getElementById('notification');
            notif.classList.add('show');
            setTimeout(() => notif.classList.remove('show'), 2000);
            
            if (state.discoMode) {
                createShout(state.player.x, state.player.y - 50, "PARTY TIME!");
            }
        }

        // Init
        initLevel();

    </script>
</body>
</html>
