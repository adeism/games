<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Pastel Stacker 3D</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Google Fonts for Cute Typography -->
    <link href="https://fonts.googleapis.com/css2?family=Varela+Round&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #fdfbfb 0%, #ebedee 100%);
            font-family: 'Varela Round', sans-serif;
            touch-action: none; /* Prevent zoom/scroll on mobile */
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 2rem;
            box-sizing: border-box;
        }

        .score-display {
            font-size: 4rem;
            color: #555;
            text-shadow: 2px 2px 0px white;
            transition: transform 0.1s ease;
        }

        .bump {
            transform: scale(1.2);
        }

        /* Start / Game Over Screen */
        #menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.4);
            backdrop-filter: blur(5px);
            z-index: 20;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            transition: opacity 0.3s ease;
        }

        .btn-start {
            background: linear-gradient(to right, #ff9a9e 0%, #fecfef 99%, #fecfef 100%);
            border: none;
            padding: 1rem 3rem;
            border-radius: 50px;
            font-size: 1.5rem;
            color: white;
            font-family: 'Varela Round', sans-serif;
            cursor: pointer;
            box-shadow: 0 10px 20px rgba(255, 154, 158, 0.3);
            transition: transform 0.2s, box-shadow 0.2s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .btn-start:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 25px rgba(255, 154, 158, 0.4);
        }

        .btn-start:active {
            transform: translateY(1px);
        }

        h1 {
            font-size: 3rem;
            color: #4a4a4a;
            margin-bottom: 0.5rem;
            text-align: center;
        }

        p.subtitle {
            font-size: 1.2rem;
            color: #888;
            margin-bottom: 2rem;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <!-- 3D Canvas Container -->
    <div id="game-container"></div>

    <!-- Gameplay UI -->
    <div id="ui-layer">
        <div id="score" class="score-display">0</div>
        <div style="text-align: center; color: #aaa; font-size: 0.9rem;">Tap / Spasi untuk menumpuk</div>
    </div>

    <!-- Menu Overlay -->
    <div id="menu-overlay">
        <h1 id="title-text">Pastel Stacker</h1>
        <p class="subtitle">Tumpuk setinggi langit!</p>
        <button id="start-btn" class="btn-start">Main</button>
    </div>

    <script>
        // --- Game Configuration & State ---
        const CONFIG = {
            boxHeight: 1,
            originalBoxSize: 3,
            speed: 0.15, // Sedikit lebih cepat agar seru
            cameraSpeed: 0.1, // Kamera lebih responsif
            colors: {
                bg: 0xf0f2f5,
                light: 0xffffff,
                shadow: 0xcccccc
            }
        };

        let state = {
            stack: [], 
            debris: [], 
            gameRunning: false,
            score: 0,
            direction: 'x', 
            currentBlock: null,
            baseBlock: null,
            cameraTargetY: 4,
            hue: 0,
            combo: 0 // Untuk perfect match bonus
        };

        // --- Audio System (Synthesizer) ---
        const AudioSys = {
            ctx: null,
            init: function() {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },
            playNote: function(baseFreq, type = 'sine', duration = 0.3) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(baseFreq, this.ctx.currentTime);
                // Pitch slide effect (cute "bloop")
                osc.frequency.exponentialRampToValueAtTime(baseFreq * 1.5, this.ctx.currentTime + 0.1);
                
                gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            playStack: function(comboLevel) {
                // Nada naik sesuai combo/score (Pentatonic scale-ish)
                const base = 261.63; // C4
                const note = base + (state.score * 20) + (comboLevel * 50);
                this.playNote(note, 'sine', 0.4);
            },
            playPerfect: function() {
                // Suara "Ting!" yang lebih tinggi
                const note = 523.25 + (state.score * 20);
                this.playNote(note, 'triangle', 0.5);
                this.playNote(note * 1.5, 'sine', 0.5); // Harmonic
            },
            playFail: function() {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(40, this.ctx.currentTime + 0.5);
                
                gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
                
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.5);
            }
        };

        // --- Three.js Setup ---
        const container = document.getElementById('game-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(CONFIG.colors.bg);
        // Add some soft fog for depth
        scene.fog = new THREE.Fog(CONFIG.colors.bg, 10, 25);

        // Camera: Orthographic looks "cuter" (isometric feel)
        const aspect = window.innerWidth / window.innerHeight;
        const d = 10;
        const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
        
        camera.position.set(10, 10, 10);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
        container.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 50;
        // Adjust shadow camera for orthographic view
        const shadowD = 20;
        dirLight.shadow.camera.left = -shadowD;
        dirLight.shadow.camera.right = shadowD;
        dirLight.shadow.camera.top = shadowD;
        dirLight.shadow.camera.bottom = -shadowD;
        scene.add(dirLight);

        // --- Game Logic Functions ---

        function getRainbowColor(offset = 0) {
            // Generate pastel rainbow colors
            const h = (state.hue + offset * 10) % 360;
            return new THREE.Color(`hsl(${h}, 70%, 75%)`);
        }

        function createBlock(x, y, z, width, depth, color) {
            const geometry = new THREE.BoxGeometry(width, CONFIG.boxHeight, depth);
            const material = new THREE.MeshLambertMaterial({ color: color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // Add custom property for animation
            mesh.userData = { 
                targetScale: { x: 1, y: 1, z: 1 },
                currentScale: { x: 1, y: 1, z: 1 }
            };
            
            return mesh;
        }

        function triggerJellyEffect(mesh) {
            // "Squash" effect
            mesh.scale.set(1.1, 0.8, 1.1); 
            // We will lerp this back to 1,1,1 in animate loop
        }

        function resetGame() {
            // Clean up old meshes
            state.stack.forEach(item => scene.remove(item.mesh));
            state.debris.forEach(obj => scene.remove(obj.mesh));
            if (state.currentBlock) scene.remove(state.currentBlock);

            state.stack = [];
            state.debris = [];
            state.score = 0;
            state.combo = 0;
            state.direction = 'x';
            state.hue = Math.random() * 360;
            state.cameraTargetY = 4;
            
            // Reset Camera
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);

            // Base Block
            const baseColor = getRainbowColor();
            const base = createBlock(0, 0, 0, CONFIG.originalBoxSize, CONFIG.originalBoxSize, baseColor);
            scene.add(base);
            state.stack.push({
                mesh: base,
                width: CONFIG.originalBoxSize,
                depth: CONFIG.originalBoxSize
            });

            spawnNextBlock();
            updateScoreUI();
        }

        function spawnNextBlock() {
            const prevBlock = state.stack[state.stack.length - 1];
            state.hue += 15; // Shift color
            const color = getRainbowColor();

            const geometry = new THREE.BoxGeometry(prevBlock.width, CONFIG.boxHeight, prevBlock.depth);
            const material = new THREE.MeshLambertMaterial({ color: color });
            state.currentBlock = new THREE.Mesh(geometry, material);
            state.currentBlock.castShadow = true;
            state.currentBlock.receiveShadow = true;
            
            // Initial animation state
            state.currentBlock.scale.set(0.1, 0.1, 0.1); // Pop in effect

            // Set start position based on direction
            const yPos = state.stack.length * CONFIG.boxHeight;
            
            // Alternate direction
            state.direction = state.direction === 'x' ? 'z' : 'x';

            const offset = 12; // Start further away
            if (state.direction === 'x') {
                state.currentBlock.position.set(-offset, yPos, prevBlock.mesh.position.z);
            } else {
                state.currentBlock.position.set(prevBlock.mesh.position.x, yPos, -offset);
            }

            scene.add(state.currentBlock);
        }

        function placeBlock() {
            if (!state.gameRunning) return;

            const current = state.currentBlock;
            const prev = state.stack[state.stack.length - 1];
            
            const prevPos = prev.mesh.position;
            const currentPos = current.position;

            let delta, overlap, size;

            if (state.direction === 'x') {
                delta = currentPos.x - prevPos.x;
                size = prev.width;
            } else {
                delta = currentPos.z - prevPos.z;
                size = prev.depth;
            }

            const absDelta = Math.abs(delta);
            overlap = size - absDelta;

            if (overlap > 0) {
                // SUCCESS
                
                // Perfect Match Bonus (Tolerance 0.15)
                const isPerfect = absDelta < 0.15;
                
                // Cut the block
                let newWidth = state.direction === 'x' ? overlap : prev.width;
                let newDepth = state.direction === 'z' ? overlap : prev.depth;
                
                // If perfect, don't cut, actually snap to size
                if (isPerfect) {
                    newWidth = prev.width;
                    newDepth = prev.depth;
                    currentPos.x = prevPos.x;
                    currentPos.z = prevPos.z;
                    state.combo++;
                    AudioSys.playPerfect();
                    
                    // Visual flare for perfect match
                    const flash = createBlock(currentPos.x, currentPos.y, currentPos.z, newWidth + 0.2, newDepth + 0.2, 0xffffff);
                    flash.material = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
                    scene.add(flash);
                    // Add to debris so it animates away quickly
                    state.debris.push({ mesh: flash, dy: 0.1, rx: 0, rz: 0, life: 10, isEffect: true });

                } else {
                    state.combo = 0;
                    AudioSys.playStack(0);
                }

                // Calculate position correction (if not perfect)
                let newX = isPerfect ? prevPos.x : prevPos.x;
                let newZ = isPerfect ? prevPos.z : prevPos.z;

                let debX, debZ, debW, debD;

                if (!isPerfect) {
                    if (state.direction === 'x') {
                        newX = prevPos.x + delta / 2;
                        debW = absDelta;
                        debD = newDepth;
                        debZ = newZ;
                        debX = currentPos.x + (delta > 0 ? overlap / 2 + debW / 2 : -overlap / 2 - debW / 2);
                    } else {
                        newZ = prevPos.z + delta / 2;
                        debW = newWidth;
                        debD = absDelta;
                        debX = newX;
                        debZ = currentPos.z + (delta > 0 ? overlap / 2 + debD / 2 : -overlap / 2 - debD / 2);
                    }
                }

                // Resize current block visuals
                scene.remove(state.currentBlock); 
                
                const placedMesh = createBlock(newX, currentPos.y, newZ, newWidth, newDepth, current.material.color);
                triggerJellyEffect(placedMesh); // BOUNCE!
                scene.add(placedMesh);
                
                state.stack.push({
                    mesh: placedMesh,
                    width: newWidth,
                    depth: newDepth
                });

                // Add Debris if not perfect
                if (!isPerfect) {
                    const debrisMesh = createBlock(debX, currentPos.y, debZ, debW || 0.1, debD || 0.1, current.material.color);
                    scene.add(debrisMesh);
                    state.debris.push({
                        mesh: debrisMesh,
                        dy: 0.1, // Pop up slightly before falling
                        rx: Math.random() * 0.2, // Spin faster
                        rz: Math.random() * 0.2
                    });
                }

                state.score++;
                updateScoreUI();
                
                // Move camera up target
                state.cameraTargetY += CONFIG.boxHeight;

                spawnNextBlock();

            } else {
                AudioSys.playFail();
                gameOver();
            }
        }

        function gameOver() {
            state.gameRunning = false;
            
            // Let the current block fall as a big chunk of debris
            state.debris.push({
                mesh: state.currentBlock,
                dy: 0.1,
                rx: Math.random() * 0.2,
                rz: Math.random() * 0.2
            });
            state.currentBlock = null;

            document.getElementById('title-text').innerText = "Game Over!";
            document.querySelector('.subtitle').innerText = "Skor: " + state.score;
            document.getElementById('start-btn').innerText = "Coba Lagi";
            document.getElementById('menu-overlay').classList.remove('hidden');
        }

        // --- Physics & Animation ---

        function updateDebris() {
            for (let i = state.debris.length - 1; i >= 0; i--) {
                const d = state.debris[i];
                
                if (d.isEffect) {
                    // Flash effect logic
                    d.mesh.material.opacity -= 0.1;
                    d.mesh.scale.x += 0.1;
                    d.mesh.scale.z += 0.1;
                    if (d.mesh.material.opacity <= 0) {
                        scene.remove(d.mesh);
                        state.debris.splice(i, 1);
                    }
                    continue;
                }

                d.dy -= 0.025; // Stronger Gravity
                d.mesh.position.y += d.dy;
                d.mesh.rotation.x += d.rx;
                d.mesh.rotation.z += d.rz;

                // Remove if too low
                if (d.mesh.position.y < -15) {
                    scene.remove(d.mesh);
                    state.debris.splice(i, 1);
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;

            if (state.gameRunning && state.currentBlock) {
                // Move current block (Ping Pong)
                const speed = CONFIG.speed + (state.score * 0.005); 
                const range = 6.5;
                const pos = Math.sin(time * speed * 20) * range; // Multiplier adjusted for speed

                if (state.direction === 'x') {
                    state.currentBlock.position.x = pos;
                } else {
                    state.currentBlock.position.z = pos;
                }
                
                // Pop-in animation for new block
                state.currentBlock.scale.x = THREE.MathUtils.lerp(state.currentBlock.scale.x, 1, 0.2);
                state.currentBlock.scale.y = THREE.MathUtils.lerp(state.currentBlock.scale.y, 1, 0.2);
                state.currentBlock.scale.z = THREE.MathUtils.lerp(state.currentBlock.scale.z, 1, 0.2);
            }

            // Animate Jelly Effect for Stack
            state.stack.forEach(block => {
                if (block.mesh.scale.y < 0.99 || block.mesh.scale.y > 1.01) {
                    block.mesh.scale.x = THREE.MathUtils.lerp(block.mesh.scale.x, 1, 0.15);
                    block.mesh.scale.y = THREE.MathUtils.lerp(block.mesh.scale.y, 1, 0.15);
                    block.mesh.scale.z = THREE.MathUtils.lerp(block.mesh.scale.z, 1, 0.15);
                }
            });

            // Smooth Camera Movement
            const desiredY = 8 + (state.stack.length * CONFIG.boxHeight);
            camera.position.y += (desiredY - camera.position.y) * CONFIG.cameraSpeed;
            camera.position.x += (10 - camera.position.x) * CONFIG.cameraSpeed; 
            camera.position.z += (10 - camera.position.z) * CONFIG.cameraSpeed;
            
            updateDebris();
            renderer.render(scene, camera);
        }

        // --- UI & Controls ---

        function updateScoreUI() {
            const el = document.getElementById('score');
            el.innerText = state.score;
            el.classList.add('bump');
            setTimeout(() => el.classList.remove('bump'), 100);
        }

        document.getElementById('start-btn').addEventListener('click', () => {
            AudioSys.init(); // Initialize Audio Context
            document.getElementById('menu-overlay').classList.add('hidden');
            resetGame();
            state.gameRunning = true;
        });

        // Input Handling
        function handleInput(e) {
            if (e.type === 'keydown' && e.code === 'Space') {
                e.preventDefault();
            }
            if (state.gameRunning) {
                placeBlock();
            }
        }

        window.addEventListener('pointerdown', handleInput);
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') handleInput(e);
        });

        // Resize Handling
        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
